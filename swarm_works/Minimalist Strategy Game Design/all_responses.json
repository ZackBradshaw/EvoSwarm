{
    "You are a game designer. Your task is to create a unique and interesting strategy game outline using Pygame. The outline should be comprehensive enough for a developer to build the entire game just by looking at it. However, keep in mind that the game should not exceed 300 lines of code, so it cannot be overly complex.": "Game Name: \"PyBattle\"\n\nGame Concept: \nPyBattle is a turn-based strategy game where two players control armies on a grid-based map. The objective is to defeat the opponent's army. Each player has different types of units with unique abilities and stats. The game ends when one player loses all their units.\n\nGame Outline:\n\n1. Game Initialization:\n    - Initialize Pygame and create a game window.\n    - Load the game assets (sprites for units, tiles for the map).\n    - Create a 2D grid to represent the game map.\n    - Place units for each player on the map.\n\n2. Game Loop:\n    - The game loop starts, which continues until the game ends.\n    - Each iteration of the game loop represents a turn.\n    - The game checks for any events (mouse clicks, key presses) and responds accordingly.\n\n3. Player's Turn:\n    - The player can select one of their units by clicking on it.\n    - Once a unit is selected, the player can move it to an adjacent tile or attack an enemy unit in an adjacent tile.\n    - Each unit can only move or attack once per turn.\n    - The player's turn ends when they have moved or attacked with all their units, or they choose to end their turn early.\n\n4. AI's Turn:\n    - The AI selects one of its units and makes a decision based on a simple algorithm (e.g., attack the closest enemy unit, move towards the closest enemy unit if no units are in attack range).\n    - The AI's turn ends when it has moved or attacked with all its units.\n\n5. Combat:\n    - When a unit attacks an enemy unit, the enemy unit's health is reduced based on the attacking unit's attack power.\n    - If a unit's health reaches 0, it is removed from the map.\n\n6. Game End:\n    - The game ends when all units of a player are defeated.\n    - A message is displayed to show who won the game.\n    - The game then returns to the initialization state, allowing players to start a new game.\n\nGame Features:\n\n1. Units: Each player has three types of units - Soldier, Archer, and Knight. Soldiers have balanced stats, Archers can attack from a distance but have low health, and Knights have high health but low attack power.\n\n2. Simple AI: The AI makes decisions based on a simple algorithm, making it a challenging but not unbeatable opponent.\n\n3. Grid-based Map: The game map is a grid, and units move on this grid. This makes the game easy to understand and play.\n\n4. Turn-based Gameplay: The game is turn-based, allowing players to take their time and think about their strategy.\n\n5. Game Restart: Players can start a new game after the current game ends, allowing for continuous play.\n\nCode Structure:\n\n1. Import Pygame and initialize game window.\n2. Load game assets.\n3. Define classes for Units and Map.\n4. Create game loop.\n5. Inside game loop, check for events and respond.\n6. Implement player's turn and AI's turn.\n7. Implement combat system.\n8. Check for game end condition and display result.\n9. Allow for game restart.\n\nThis outline provides a comprehensive guide to developing the PyBattle game using Pygame. The game is simple yet engaging, with a focus on strategic decision-making. The code structure is organized and efficient, ensuring the game can be implemented within the 300 lines of code limit.",
    "You are a Pygame expert. Your role is to design a strategy game that is not only unique and interesting but also concise. The game should be simple enough to be implemented within 300 lines of code, yet engaging enough to captivate players. Remember, the outline you provide should be so detailed that a developer can build the game solely based on it.": "Game Title: \"EcoBalance\"\n\nGame Concept: \nEcoBalance is a simple yet engaging strategy game where the player must balance the growth of a small ecosystem. The player will have to manage three main elements: plants, herbivores, and carnivores. The goal is to keep the ecosystem balanced for as long as possible.\n\nGameplay Mechanics: \n\n1. Game Board: The game board is a grid of 10x10 squares. Each square can contain a plant, a herbivore, or a carnivore.\n\n2. Game Elements: \n   - Plants: They grow randomly on the grid at the start of each turn.\n   - Herbivores: They eat plants to survive. If a herbivore doesn't eat for three turns, it dies.\n   - Carnivores: They eat herbivores to survive. If a carnivore doesn't eat for three turns, it dies.\n\n3. Player Actions: Each turn, the player can perform two actions from the following:\n   - Plant a tree: The player can add a plant to any empty square.\n   - Move a herbivore: The player can move a herbivore to an adjacent square to eat a plant.\n   - Move a carnivore: The player can move a carnivore to an adjacent square to eat a herbivore.\n\n4. Scoring: The player earns points for each turn the ecosystem remains balanced. The ecosystem is considered balanced if there are at least one plant, one herbivore, and one carnivore alive.\n\n5. End of Game: The game ends when the ecosystem becomes unbalanced (i.e., when any of the three elements is wiped out).\n\nGame Flow:\n\n1. The game starts with a random distribution of plants, herbivores, and carnivores on the grid.\n\n2. The player performs two actions.\n\n3. New plants grow on random empty squares.\n\n4. Herbivores and carnivores act according to their nature (herbivores eat adjacent plants and carnivores eat adjacent herbivores). If they can't eat, they get closer to starvation.\n\n5. The player's score increases if the ecosystem is balanced.\n\n6. Steps 2-5 repeat until the ecosystem becomes unbalanced.\n\n7. The player's final score is displayed.\n\nUser Interface:\n\n1. The game board is displayed in the center of the screen.\n\n2. The current score and the number of each element left are displayed at the top of the screen.\n\n3. Buttons for the player actions (plant a tree, move a herbivore, move a carnivore) are displayed at the bottom of the screen.\n\n4. A message box displaying game messages (e.g., \"Herbivore starved\", \"Ecosystem unbalanced\") is displayed below the game board.\n\nArt Style: \n\nThe game will have a minimalist art style with simple shapes and colors to represent the different elements (green squares for plants, blue circles for herbivores, red triangles for carnivores).\n\nSound Effects: \n\nSimple sound effects will be used to enhance the gameplay experience (e.g., a crunching sound when a herbivore eats a plant, a growling sound when a carnivore eats a herbivore).\n\nIn summary, EcoBalance is a simple strategy game that challenges the player to maintain a balance in a small ecosystem. The game's simplicity makes it easy to implement within 300 lines of code, while its strategic depth and random elements ensure that it remains engaging for the players.",
    "You are a minimalist game developer. Your challenge is to design a strategy game using Pygame that is both engaging and concise. The game should be simple, yet unique and interesting. The entire game should not exceed 300 lines of code, and the outline should be so comprehensive that a developer can create the game just by looking at it.": "Game Title: \"Minimalist Conquest\"\n\n1. Game Overview:\nMinimalist Conquest is a turn-based strategy game where the player controls a faction to conquer territories on a grid-based map. The player wins by capturing all territories. The game is designed to be simple yet engaging, with a focus on strategic decision-making.\n\n2. Game Mechanics:\n\n2.1. Grid: The game world is a 10x10 grid, each cell representing a territory. Territories are either owned by the player, the enemy, or neutral.\n\n2.2. Units: Each territory has a number of units. At the start, player and enemy territories have 5 units each, neutral territories have 2 units.\n\n2.3. Turns: The player and the enemy take turns. On their turn, they can perform one action: move units or pass.\n\n2.4. Moving Units: The player can move units from one of their territories to an adjacent territory. If the target territory is owned by the enemy or neutral, it's an attack. If it's owned by the player, it's a reinforcement.\n\n2.5. Attacks: The attacking territory loses the number of units moved. The defending territory loses twice the number of units. If the defending territory loses all units, the attacker takes over. If not, the territory remains with the defender.\n\n2.6. Reinforcements: The player can move units to reinforce their own territories. The number of units in the target territory increases by the number moved.\n\n2.7. Unit Generation: At the start of each turn, each territory owned by the player generates one new unit.\n\n3. Game Flow:\n\n3.1. Initialization: Initialize the grid with player, enemy, and neutral territories. Assign units to each territory.\n\n3.2. Player Turn: The player chooses a territory to move units from and an adjacent territory to move units to. Apply the move rules.\n\n3.3. Enemy Turn: The enemy AI chooses a move. Apply the move rules.\n\n3.4. Check Win/Loss: If the player owns all territories, they win. If the enemy owns all territories, the player loses.\n\n3.5. Repeat: Repeat steps 3.2 to 3.4 until the game ends.\n\n4. Pygame Implementation:\n\n4.1. Grid: Use a 2D array to represent the grid. Each cell contains an object with properties for owner and number of units.\n\n4.2. Graphics: Use simple shapes and colors to represent territories and units. Player territories are blue, enemy territories are red, neutral territories are grey. The number of units is displayed on each territory.\n\n4.3. Input: Use mouse clicks to select territories. The first click selects the territory to move units from, the second click selects the territory to move units to.\n\n4.4. AI: Implement a simple AI for the enemy. The AI randomly selects a territory to move units from and an adjacent territory to move units to.\n\n4.5. Game Loop: The main game loop handles input, updates the game state, and redraws the screen.\n\n5. Code Structure:\n\n5.1. Main: The main function initializes Pygame, sets up the game state, and starts the game loop.\n\n5.2. Game State: A class that represents the game state. It has methods for initializing the game, performing moves, and checking win/loss conditions.\n\n5.3. AI: A function that takes the game state and returns a move for the enemy.\n\n5.4. Drawing: Functions for drawing the grid, territories, and units.\n\n5.5. Input: Functions for handling mouse clicks and converting them to moves.\n\n5.6. Game Loop: The game loop function runs the game. It handles input, updates the game state, runs the AI, and redraws the screen."
}